{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.component.jsx","App.js","reportWebVitals.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","SearchBox","placeholder","handleChange","type","onChange","App","state","searchField","bind","fetch","then","response","json","users","setState","e","this","target","value","filteredMonsters","filter","toLowerCase","includes","toLocaleLowerCase","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6TAIaA,G,MAAO,SAAAC,GAAK,OACrB,sBAAKC,UAAU,iBAAf,UACI,qBAAMC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACvB,6BAAML,EAAMI,QAAQE,OACpB,4BAAKN,EAAMI,QAAQG,aCAdC,G,MAAW,SAAAR,GAAK,OACzB,qBAAKC,UAAU,YAAf,SACKD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OACvB,cAAC,EAAD,CAAuBA,QAASA,GAArBA,EAAQC,WCHlBM,G,MAAY,SAAC,GAAD,IAAGC,EAAH,EAAGA,YAAaC,EAAhB,EAAgBA,aAAhB,OACrB,uBACAZ,UAAU,SACVa,KAAK,SACLF,YAAaA,EACbG,SAAUF,MCsECG,G,wDAtEb,aAAe,IAAD,8BACZ,gBAEKC,MAAQ,CAEXR,SAAU,GACVS,YAAa,IAOf,EAAKL,aAAe,EAAKA,aAAaM,KAAlB,gBAbR,E,gEAgBO,IAAD,OAClBC,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKC,SAAS,CAAEhB,SAAUe,S,mCAG9BE,GAKXC,KAAKF,SAAS,CAAEP,YAAaQ,EAAEE,OAAOC,U,+BAW/B,MAE2BF,KAAKV,MAA/BR,EAFD,EAECA,SAAUS,EAFX,EAEWA,YAOZY,EAAmBrB,EAASsB,QAAO,SAAA3B,GAAO,OAC5CA,EAAQE,KAAK0B,cAAcC,SAASf,EAAYgB,wBAGpD,OACE,sBAAKjC,UAAU,MAAf,UACE,kDACA,cAAC,EAAD,CACEW,YAAY,kBACZC,aAAec,KAAKd,eAGtB,cAAC,EAAD,CAAUJ,SAAUqB,W,GA7DVK,cCCHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBjB,MAAK,YAAkD,IAA/CkB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.c23bcee9.chunk.js","sourcesContent":["import React from 'react';\n\nimport './card.styles.css'\n\nexport const Card = props => (\n    <div className='card-container'>\n        <img  alt=\"monster\" src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`} />\n        <h2>{ props.monster.name }</h2>\n        <p>{ props.monster.email }</p>\n    </div>\n)","import React from 'react';\n\nimport { Card } from '../card/card.component';\n\nimport './card-list.styles.css';\n\n// esto es un functional component - existen los functional components y los class components: https://www.freecodecamp.org/news/functional-components-vs-class-components-in-react/\n// algo importante de los componentes, es que toman \"props\", que son los parámetros que obtenemos del componente.\nexport const CardList = props => (\n    <div className='card-list'>\n        {props.monsters.map(monster => (\n            <Card key={monster.id} monster={monster} />\n        ))}\n    </div>\n);","import React from 'react';\n\nimport './search-box.styles.css';\n\n// functional component: no tienen acceso a state, ya que no tienen acceso a Constructor, porque no tienen acceso a Component\n// no tiene acceso a life-cycle methods, no tienen nada de esto, porque no lo necesitan, no siempre es necesario crear Class Components\n// algunas veces, solo es necesario desplegar algún contenido HTML, y ahí es donde se crean y funcionan esto functional components.\n// un functional component, en pocas palabras, es una función que recibe algunos props y con eso despliega HTML\nexport const SearchBox = ({ placeholder, handleChange }) => (\n    <input\n    className='search' \n    type='search' \n    placeholder={placeholder}\n    onChange={handleChange}\n    /> \n);\n\n/* el hecho de usar type \"search\" me permite agregar un place holder al input, con onChange, e representa \nun evento sintético que se le envía como parámetro,  setState es un evento asíncrono, por lo tanto, \nsi se quiere ejecutar un evento realmente después de que se complete el setState, se puede enviar como \nsegundo parámetro como en este caso por medio del uso de \"() =>\" */","import React, { Component } from 'react' // importo component con el fin de utilizar clases\n\nimport { CardList } from './components/card-list/card-list.component.jsx';\nimport { SearchBox } from './components/search-box/search-box.component.jsx';\n\nimport './App.css';\n\n\n// Component, me da acceso a usar el método render()\n// dentro de las clases puedo usar state, el cual es un obejto de js con propiedades, que se puede accesar desde cualquier punto dentro de la clase\n// Component, también da acceso acceso al método setState, el cual permite cambiar los valores de las propiedades del state\nclass App extends Component {\n  // los constructores se ejecutan de primero siempre, antes que cualquier otra cosa dentro de la clase\n  constructor() { // los constructores en react solo se utilizan para dos propósitos, 1. para inicializar un estado local asignando un objeto al this.state. 2. Para enlazar manejadores de eventos a una instancia\n    super(); // super, llama el método constructor, de Component que es su padre, lo cual da acceso a this.state\n\n    this.state = { //this.state asigna el estado inicial, setState lo modifica luego, ya fuera del constructor.\n      //dentro de este state, se crean las propiedades que se usarán a lo largo y dentro de la clase\n      monsters: [], // el estado inicial es un array vacío, que cuando se monta, pasa a ejecutarse componentDidMount, y ahí empieza a llamar el API y hacer el setState que luego renderiza la lista con un map()\n      searchField: '' // lo que se digita en el campo de búsqueda, se debe almacenar en el state, para luego poder filtrar\n    }\n\n    // Este enlace usando 'bind' es necesario para hacer que 'this' funcione en el callback, es decir, \n    // por si solo, dentro del método 'handleChange' creado, this no tiene contexto hacia  App como si la \n    // tienen los demás métodos de life-cycle por ejemplo.\n    // https://es.reactjs.org/docs/handling-events.html\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  componentDidMount() {// lo que hace este método es que cuando el componente se monta (cuando react pone el componente en la página por primera vez), se ejecuta lo que sea que haya en este bloque de código\n    fetch('https://jsonplaceholder.typicode.com/users') // retorna promise\n    .then(response => response.json()) //  retorna promise\n    .then(users => this.setState({ monsters: users })); // el setState asigna la respuesta de la promise, a la propiedad monsters del estado\n  }\n\n  handleChange(e) {\n    // this.setState funciona acá gracias al enlace creado con .bind en el constructor.\n    // SIN EMBARGO, esto ya no es necesario desde ES6 gracias a los arrow functions, \n    // que definen el contexto basado en el objeto donde se están creando (lexica scope), \n    // como en este caso handleChange dentro de App.\n    this.setState({ searchField: e.target.value })\n  }\n\n  //forma correcta de manejar el handleChange con ES6 sin necesidad de crear un enlace con bind en el constructor\n  /* handleChange = (e)  => {\n    this.setState({ searchField: e.target.value })\n  } */\n  // una buena regla, es usar arrow functions SIEMPRE que se defina una clase propia \n  // (que no sea de react), con solo eso se evita la necesidad del bind y código adicional, aparte que se ve más limpio\n\n\n  render() {\n    //destructured\n    const { monsters, searchField } = this.state;\n    // abajo, lo mismo de arriba pero de la forma antigua y clásica\n      // const monsters = this.state.monsters\n      // const searchField = this.state.searchField\n\n    // por medio de este filtro, se logra que dinámicamente se renderice el app con las búsquedas que hace el usuario\n    // ya que este filtro, es pasado como prop a CardList y se renderiza nuevamente gracias al onChange en el input.\n    const filteredMonsters = monsters.filter(monster =>\n        monster.name.toLowerCase().includes(searchField.toLocaleLowerCase())\n        )\n\n    return (\n      <div className=\"App\">\n        <h1>Monsters Rolodex</h1>\n        <SearchBox\n          placeholder='search monsters' \n          handleChange= {this.handleChange}\n          /* Esta función recibe un evento como parámetro, representado por la letra e en este caso */\n        />\n        <CardList monsters={filteredMonsters}>\n          {/* map, retorna el retorno de cualquier función que se le pase, iterado sobre cada elemento en un array */}\n          {/* además de los parámetros, al componente le puedo enviar \"children\", y sería cualquier cosa que se envíe dentro de los tags del componente, puede ser cualquier cosa  */}\n          {/* Los children no se renderizan automáticamente, es necesario hacerlo en el componente como tal, se llaman dentro de brackets de esta manera: {props.children} */}\n        </CardList>\n        { /* Los brackets son necesarios, dentro de estos, se puede remderizar lo que sea en js*/ }\n      </div>\n    ); // return cierra con ;\n  }\n}\n\nexport default App;\n\n// setState\n// En react, la unica forma en que se puede actualizar el estado del componente, es por medio del uso de setState. \n// no es posible, como en JS normal, asignar un valor a una variable, por ejemplo, esto porque la forma en que funciona\n// react, donde la data fluye en un solo sentido, no permite este tipo de acciones.\n\n// setState  y render\n// de la forma en que funciona react, el componente se renderiza (render()), cada vez que se actualiza el estado\n// es decir, cuando una acción, ejecuta un setState, y se actualiza el estado, se vuelve a ejecutar render()\n\n// JSX\n// Hay que tener en cuenta, que en react, nunca se está escribiendo HTML por más que se le asemeje, siempre\n// se está escribiendo código JSX, como \"className\", \"onClick\", \"src\"\n\n// Lifecycle methods\n// métodos que se llaman en diferente etapas de cuando el componente es renderizado. tales como componentDidMount, componentDidUpdate, componentWillUnmount...\n\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}