{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/melvinalfaro/monsters-rolodex/src/App.js\";\nimport React, { Component } from 'react'; // importo component con el fin de utilizar clases\n\nimport { CardList } from './components/card-list/card-list.component.jsx';\nimport { SearchBox } from './components/search-box/search-box.component.jsx';\nimport './App.css'; // Component, me da acceso a usar el método render()\n// dentro de las clases puedo usar state, el cual es un obejto de js con propiedades, que se puede accesar desde cualquier punto dentro de la clase\n// Component, también da acceso acceso al método setState, el cual permite cambiar los valores de las propiedades del state\n\nclass App extends Component {\n  constructor() {\n    // los constructores en react solo se utilizan para dos propósitos, 1. para inicializar un estado local asignando un objeto al this.state. 2. Para enlazar manejadores de eventos a una instancia\n    super(); // super, llama el método constructor, de Component que es su padre, lo cual da acceso a this.state\n\n    this.state = {\n      //this.state asigna el estado inicial, setState lo modifica luego, ya fuera del constructor.\n      //dentro de este state, se crean las propiedades que se usarán a lo largo y dentro de la clase\n      monsters: [],\n      // el estado inicial es un array vacío, que cuando se monta, pasa a ejecutarse componentDidMount, y ahí empieza a llamar el API y hacer el setState que luego renderiza la lista con un map()\n      searchField: '' // lo que se digita en el campo de búsqueda, se debe almacenar en el state, para luego poder filtrar\n\n    };\n  }\n\n  componentDidMount() {\n    // lo que hace este método es que cuando el componente se monta (cuando react pone el componente en la página por primera vez), se ejecuta lo que sea que haya en este bloque de código\n    fetch('https://jsonplaceholder.typicode.com/users') // retorna promise\n    .then(response => response.json()) //  retorna promise\n    .then(users => this.setState({\n      monsters: users\n    })); // el setState asigna la respuesta de la promise, a la propiedad monsters del estado\n  }\n\n  render() {\n    //destructured\n    const {\n      monsters,\n      searchField\n    } = this.state; // abajo, lo mismo de arriba pero de la forma antigua y clásica\n    // const monsters = this.state.monsters\n    // const searchField = this.state.searchField\n    // por medio de este filtro, se logra que dinámicamente se renderice el app con las búsquedas que hace el usuario\n    // ya que este filtro, es pasado como prop a CardList y se renderiza nuevamente gracias al onChange en el input.\n\n    const filteredMonsters = monsters.filter(monster => monster.name.toLowerCase().includes(searchField.toLocaleLowerCase()));\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: [/*#__PURE__*/_jsxDEV(SearchBox, {\n        placeholder: \"search monsters\",\n        handleChange: e => this.setState({\n          searchField: e.target.value\n        })\n        /* Esta función recibe un evento como parámetro, representado por la letra e en este caso */\n\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(CardList, {\n        monsters: filteredMonsters\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 44,\n      columnNumber: 7\n    }, this); // return cierra con ;\n  }\n\n}\n\nexport default App; // setState\n// En react, la unica forma en que se puede actualizar el estado del componente, es por medio del uso de setState. \n// no es posible, como en JS normal, asignar un valor a una variable, por ejemplo, esto porque la forma en que funciona\n// react, donde la data fluye en un solo sentido, no permite este tipo de acciones.\n// setState  y render\n// de la forma en que funciona react, el componente se renderiza (render()), cada vez que se actualiza el estado\n// es decir, cuando una acción, ejecuta un setState, y se actualiza el estado, se vuelve a ejecutar render()\n// JSX\n// Hay que tener en cuenta, que en react, nunca se está escribiendo HTML por más que se le asemeje, siempre\n// se está escribiendo código JSX, como \"className\", \"onClick\", \"src\"\n// Lifecycle methods\n// métodos que se llaman en diferente etapas de cuando el componente es renderizado. tales como componentDidMount, componentDidUpdate, componentWillUnmount...","map":{"version":3,"sources":["/Users/melvinalfaro/monsters-rolodex/src/App.js"],"names":["React","Component","CardList","SearchBox","App","constructor","state","monsters","searchField","componentDidMount","fetch","then","response","json","users","setState","render","filteredMonsters","filter","monster","name","toLowerCase","includes","toLocaleLowerCase","e","target","value"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC,C,CAAyC;;AAEzC,SAASC,QAAT,QAAyB,gDAAzB;AACA,SAASC,SAAT,QAA0B,kDAA1B;AAEA,OAAO,WAAP,C,CAGA;AACA;AACA;;AACA,MAAMC,GAAN,SAAkBH,SAAlB,CAA4B;AAC1BI,EAAAA,WAAW,GAAG;AAAE;AACd,YADY,CACH;;AAET,SAAKC,KAAL,GAAa;AAAE;AACb;AACAC,MAAAA,QAAQ,EAAE,EAFC;AAEG;AACdC,MAAAA,WAAW,EAAE,EAHF,CAGK;;AAHL,KAAb;AAMD;;AAEDC,EAAAA,iBAAiB,GAAG;AAAC;AACnBC,IAAAA,KAAK,CAAC,4CAAD,CAAL,CAAoD;AAApD,KACCC,IADD,CACMC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,EADlB,EACmC;AADnC,KAECF,IAFD,CAEMG,KAAK,IAAI,KAAKC,QAAL,CAAc;AAAER,MAAAA,QAAQ,EAAEO;AAAZ,KAAd,CAFf,EADkB,CAGkC;AACrD;;AAEDE,EAAAA,MAAM,GAAG;AACP;AACA,UAAM;AAAET,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAA4B,KAAKF,KAAvC,CAFO,CAGP;AACE;AACA;AAEF;AACA;;AACA,UAAMW,gBAAgB,GAAGV,QAAQ,CAACW,MAAT,CAAgBC,OAAO,IAC5CA,OAAO,CAACC,IAAR,CAAaC,WAAb,GAA2BC,QAA3B,CAAoCd,WAAW,CAACe,iBAAZ,EAApC,CADqB,CAAzB;AAIA,wBACE;AAAK,MAAA,SAAS,EAAC,KAAf;AAAA,8BACE,QAAC,SAAD;AACE,QAAA,WAAW,EAAC,iBADd;AAEE,QAAA,YAAY,EAAGC,CAAC,IAAI,KAAKT,QAAL,CAAc;AAAEP,UAAAA,WAAW,EAAEgB,CAAC,CAACC,MAAF,CAASC;AAAxB,SAAd;AACpB;;AAHF;AAAA;AAAA;AAAA;AAAA,cADF,eAME,QAAC,QAAD;AAAU,QAAA,QAAQ,EAAET;AAApB;AAAA;AAAA;AAAA;AAAA,cANF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF,CAbO,CA2BJ;AACJ;;AA9CyB;;AAiD5B,eAAeb,GAAf,C,CAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA","sourcesContent":["import React, { Component } from 'react' // importo component con el fin de utilizar clases\n\nimport { CardList } from './components/card-list/card-list.component.jsx';\nimport { SearchBox } from './components/search-box/search-box.component.jsx';\n\nimport './App.css';\n\n\n// Component, me da acceso a usar el método render()\n// dentro de las clases puedo usar state, el cual es un obejto de js con propiedades, que se puede accesar desde cualquier punto dentro de la clase\n// Component, también da acceso acceso al método setState, el cual permite cambiar los valores de las propiedades del state\nclass App extends Component {\n  constructor() { // los constructores en react solo se utilizan para dos propósitos, 1. para inicializar un estado local asignando un objeto al this.state. 2. Para enlazar manejadores de eventos a una instancia\n    super(); // super, llama el método constructor, de Component que es su padre, lo cual da acceso a this.state\n\n    this.state = { //this.state asigna el estado inicial, setState lo modifica luego, ya fuera del constructor.\n      //dentro de este state, se crean las propiedades que se usarán a lo largo y dentro de la clase\n      monsters: [], // el estado inicial es un array vacío, que cuando se monta, pasa a ejecutarse componentDidMount, y ahí empieza a llamar el API y hacer el setState que luego renderiza la lista con un map()\n      searchField: '' // lo que se digita en el campo de búsqueda, se debe almacenar en el state, para luego poder filtrar\n    }\n\n  }\n\n  componentDidMount() {// lo que hace este método es que cuando el componente se monta (cuando react pone el componente en la página por primera vez), se ejecuta lo que sea que haya en este bloque de código\n    fetch('https://jsonplaceholder.typicode.com/users') // retorna promise\n    .then(response => response.json()) //  retorna promise\n    .then(users => this.setState({ monsters: users })); // el setState asigna la respuesta de la promise, a la propiedad monsters del estado\n  }\n\n  render() {\n    //destructured\n    const { monsters, searchField } = this.state;\n    // abajo, lo mismo de arriba pero de la forma antigua y clásica\n      // const monsters = this.state.monsters\n      // const searchField = this.state.searchField\n\n    // por medio de este filtro, se logra que dinámicamente se renderice el app con las búsquedas que hace el usuario\n    // ya que este filtro, es pasado como prop a CardList y se renderiza nuevamente gracias al onChange en el input.\n    const filteredMonsters = monsters.filter(monster =>\n        monster.name.toLowerCase().includes(searchField.toLocaleLowerCase())\n        )\n\n    return (\n      <div className=\"App\">\n        <SearchBox\n          placeholder='search monsters' \n          handleChange= {e => this.setState({ searchField: e.target.value })}\n          /* Esta función recibe un evento como parámetro, representado por la letra e en este caso */\n        />\n        <CardList monsters={filteredMonsters}>\n          {/* map, retorna el retorno de cualquier función que se le pase, iterado sobre cada elemento en un array */}\n          {/* además de los parámetros, al componente le puedo enviar \"children\", y sería cualquier cosa que se envíe dentro de los tags del componente, puede ser cualquier cosa  */}\n          {/* Los children no se renderizan automáticamente, es necesario hacerlo en el componente como tal, se llaman dentro de brackets de esta manera: {props.children} */}\n        </CardList>\n        { /* Los brackets son necesarios, dentro de estos, se puede remderizar lo que sea en js*/ }\n      </div>\n    ); // return cierra con ;\n  }\n}\n\nexport default App;\n\n// setState\n// En react, la unica forma en que se puede actualizar el estado del componente, es por medio del uso de setState. \n// no es posible, como en JS normal, asignar un valor a una variable, por ejemplo, esto porque la forma en que funciona\n// react, donde la data fluye en un solo sentido, no permite este tipo de acciones.\n\n// setState  y render\n// de la forma en que funciona react, el componente se renderiza (render()), cada vez que se actualiza el estado\n// es decir, cuando una acción, ejecuta un setState, y se actualiza el estado, se vuelve a ejecutar render()\n\n// JSX\n// Hay que tener en cuenta, que en react, nunca se está escribiendo HTML por más que se le asemeje, siempre\n// se está escribiendo código JSX, como \"className\", \"onClick\", \"src\"\n\n// Lifecycle methods\n// métodos que se llaman en diferente etapas de cuando el componente es renderizado. tales como componentDidMount, componentDidUpdate, componentWillUnmount...\n\n"]},"metadata":{},"sourceType":"module"}